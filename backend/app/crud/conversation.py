# CRUD operations for Conversation model
# TODO: Implement these functions to manage conversations

from datetime import datetime
from math import log
from sqlalchemy.ext.asyncio.session import AsyncSession
from sqlalchemy import select, and_
import uuid
from app.db import User
from typing import Optional

from app.models import Conversation
from app.schemas import ConversationCreate


# TODO: I kind of want to make an assumption here that the user has to have sent a message already before we ever create a conversation, but that might be problematic, so let's not.
async def create_conversation_service(
    user_id: uuid.UUID, session: AsyncSession, schema_data: ConversationCreate
) -> Conversation:
    """
    Create a new conversation.

    Note: Title will be generated by LLM from first message, so schema_data may be empty.
    """
    # TODO: Decide on title strategy:
    # - Use default title ("New Conversation") and update after first message?
    # - Generate title immediately using schema_data.title if provided?
    # - Use LLM to generate from first message in chat endpoint?
    new_conversation = Conversation(
        user_id=user_id,
        title="New Conversation",  # TODO: Replace with LLM-generated or schema_data.title,
        created_at=datetime.now(),
        updated_at=datetime.now(),
    )
    session.add(new_conversation)
    await session.commit()
    await session.refresh(new_conversation)
    return new_conversation


async def get_conversation_service(
    user_id: uuid.UUID, session: AsyncSession, conversation_id: uuid.UUID
) -> Optional[Conversation]:
    """
    Retrieve a single conversation by ID, ensuring it belongs to the user.

    This is important for security - users should only access their own conversations.

    Returns:
        Conversation object if found, None otherwise
    """

    # This gives us the actual user with the user id...maybe?
    usrSelect = select(User).where(User.id == user_id)
    print("usrSelect", usrSelect)
    print("outcome", await session.execute(usrSelect))


# TODO: Implement function to get a single conversation by ID
# async def get_conversation(
#     session: AsyncSession,
#     conversation_id: uuid.UUID,
#     user_id: uuid.UUID
# ) -> Optional[Conversation]:
#     """
#     Retrieve a single conversation by ID, ensuring it belongs to the user.
#
#     This is important for security - users should only access their own conversations.
#
#     Returns:
#         Conversation object if found, None otherwise
#     """
#     result = await session.execute(
#         select(Conversation).where(
#             and_(
#                 Conversation.id == conversation_id,
#                 Conversation.user_id == user_id
#             )
#         )
#     )
#     return result.scalar_one_or_none()
#     pass


# TODO: Implement function to get all conversations for a user
# async def get_conversations_for_user(
#     session: AsyncSession,
#     user_id: uuid.UUID,
#     skip: int = 0,
#     limit: int = 100
# ) -> list[Conversation]:
#     """
#     Retrieve all conversations for a specific user.
#
#     Returns:
#         List of Conversation objects, ordered by updated_at DESC (most recent first)
#     """
#     result = await session.execute(
#         select(Conversation)
#         .where(Conversation.user_id == user_id)
#         .order_by(Conversation.updated_at.desc())
#         .offset(skip)
#         .limit(limit)
#     )
#     return list(result.scalars().all())
#     pass


# TODO: Implement function to update conversation (title, etc.)
# async def update_conversation(
#     session: AsyncSession,
#     conversation_id: uuid.UUID,
#     user_id: uuid.UUID,
#     update_data: ConversationUpdate
# ) -> Optional[Conversation]:
#     """
#     Update conversation metadata (title, etc.).
#
#     Use case:
#     - Update title after LLM generates it from first message
#     - Update title when user renames conversation
#
#     Returns:
#         Updated Conversation object if found, None otherwise
#     """
#     db_conversation = await get_conversation(session, conversation_id, user_id)
#     if not db_conversation:
#         return None
#
#     # Update only provided fields
#     update_dict = update_data.model_dump(exclude_unset=True)
#     for field, value in update_dict.items():
#         setattr(db_conversation, field, value)
#
#     db_conversation.updated_at = datetime.utcnow()
#     await session.commit()
#     await session.refresh(db_conversation)
#     return db_conversation
#     pass


# TODO: Implement function to delete conversation (cascade delete messages)
# async def delete_conversation(
#     session: AsyncSession,
#     conversation_id: uuid.UUID,
#     user_id: uuid.UUID
# ) -> bool:
#     """
#     Delete a conversation and all its messages.
#
#     Note: This only deletes from your database.
#     You should also clear the Agno session to cleanup its database.
#
#     Returns:
#         True if deleted, False if not found
#     """
#     db_conversation = await get_conversation(session, conversation_id, user_id)
#     if not db_conversation:
#         return False
#
#     await session.delete(db_conversation)
#     await session.commit()
#     return True
#     pass
