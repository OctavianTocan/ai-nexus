# CRUD operations for Conversation model
# TODO: Implement these functions to manage conversations

from backend.app.models import Message

from datetime import datetime
from math import log
from agno.agent import Message
from sqlalchemy.ext.asyncio.session import AsyncSession
from sqlalchemy import select, and_
import uuid
from app.db import User
from typing import Optional

from app.models import Conversation
from app.schemas import ConversationCreate


# TODO: I kind of want to make an assumption here that the user has to have sent a message already before we ever create a conversation, but that might be problematic, so let's not.
async def create_conversation_service(
    user_id: uuid.UUID, session: AsyncSession, schema_data: ConversationCreate
) -> Conversation:
    """
    Create a new conversation.

    Note: Title will be generated by LLM from first message, so schema_data may be empty.
    """
    # TODO: Decide on title strategy:
    # - Use default title ("New Conversation") and update after first message?
    # - Generate title immediately using schema_data.title if provided?
    # - Use LLM to generate from first message in chat endpoint?
    new_conversation = Conversation(
        user_id=user_id,
        title="New Conversation",  # TODO: Replace with LLM-generated or schema_data.title,
        created_at=datetime.now(),
        updated_at=datetime.now(),
    )
    session.add(new_conversation)
    await session.commit()
    await session.refresh(new_conversation)
    return new_conversation


async def get_conversation_service(
    user_id: uuid.UUID, session: AsyncSession, conversation_id: uuid.UUID
) -> Optional[Conversation]:
    """
    Retrieve a single conversation by ID, ensuring it belongs to the user.

    This is important for security - users should only access their own conversations.

    Returns:
        Conversation object if found, None otherwise
    """

    # Select the conversation by ID and user ID.
    # This already ensures that the conversation belongs to the user, because we're making sure that the user_id is the same as the user_id of the conversation.
    conversationSelect = (
        select(Conversation)
        .where(Conversation.id == conversation_id)
        .where(Conversation.user_id == user_id)
    )
    # Execute the select statement and get the conversation.
    conversationResult = await session.execute(conversationSelect)
    return conversationResult.scalar_one_or_none()


async def get_conversation_messages_service(
    user_id: uuid.UUID, session: AsyncSession, conversation_id: uuid.UUID
) -> list[Message]:
    """
    Get the messages for a conversation.
    Args:
        user_id: The ID of the user.
        session: The database session.
        conversation_id: The ID of the conversation.
    Returns:
        list[Message]: The list of messages for the conversation.
    """

    # Get the conversation.
    conversation = await get_conversation_service(user_id, session, conversation_id)
    # If the conversation is not found, we return None.
    if not conversation:
        return None

    # Return the messages for the conversation.
    # TODO: Right now this won't return anything, because we're not adding messages to our own database, just the Agno database.
    return list[Message](conversation.messages)


# TODO: Implement function to get a single conversation by ID
# async def get_conversation(
#     session: AsyncSession,
#     conversation_id: uuid.UUID,
#     user_id: uuid.UUID
# ) -> Optional[Conversation]:
#     """
#     Retrieve a single conversation by ID, ensuring it belongs to the user.
#
#     This is important for security - users should only access their own conversations.
#
#     Returns:
#         Conversation object if found, None otherwise
#     """
#     result = await session.execute(
#         select(Conversation).where(
#             and_(
#                 Conversation.id == conversation_id,
#                 Conversation.user_id == user_id
#             )
#         )
#     )
#     return result.scalar_one_or_none()
#     pass


# TODO: Implement function to get all conversations for a user
# async def get_conversations_for_user(
#     session: AsyncSession,
#     user_id: uuid.UUID,
#     skip: int = 0,
#     limit: int = 100
# ) -> list[Conversation]:
#     """
#     Retrieve all conversations for a specific user.
#
#     Returns:
#         List of Conversation objects, ordered by updated_at DESC (most recent first)
#     """
#     result = await session.execute(
#         select(Conversation)
#         .where(Conversation.user_id == user_id)
#         .order_by(Conversation.updated_at.desc())
#         .offset(skip)
#         .limit(limit)
#     )
#     return list(result.scalars().all())
#     pass


# TODO: Implement function to update conversation (title, etc.)
# async def update_conversation(
#     session: AsyncSession,
#     conversation_id: uuid.UUID,
#     user_id: uuid.UUID,
#     update_data: ConversationUpdate
# ) -> Optional[Conversation]:
#     """
#     Update conversation metadata (title, etc.).
#
#     Use case:
#     - Update title after LLM generates it from first message
#     - Update title when user renames conversation
#
#     Returns:
#         Updated Conversation object if found, None otherwise
#     """
#     db_conversation = await get_conversation(session, conversation_id, user_id)
#     if not db_conversation:
#         return None
#
#     # Update only provided fields
#     update_dict = update_data.model_dump(exclude_unset=True)
#     for field, value in update_dict.items():
#         setattr(db_conversation, field, value)
#
#     db_conversation.updated_at = datetime.utcnow()
#     await session.commit()
#     await session.refresh(db_conversation)
#     return db_conversation
#     pass


# TODO: Implement function to delete conversation (cascade delete messages)
# async def delete_conversation(
#     session: AsyncSession,
#     conversation_id: uuid.UUID,
#     user_id: uuid.UUID
# ) -> bool:
#     """
#     Delete a conversation and all its messages.
#
#     Note: This only deletes from your database.
#     You should also clear the Agno session to cleanup its database.
#
#     Returns:
#         True if deleted, False if not found
#     """
#     db_conversation = await get_conversation(session, conversation_id, user_id)
#     if not db_conversation:
#         return False
#
#     await session.delete(db_conversation)
#     await session.commit()
#     return True
#     pass
