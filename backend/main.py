import json
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from datetime import datetime

from agno.agent import Agent
from agno.db.sqlite import SqliteDb
from agno.models.google import Gemini
from agno.os import AgentOS
from agno.tools.mcp import MCPTools
from dotenv import load_dotenv
from fastapi import Depends, FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from sqlalchemy.ext.asyncio.session import AsyncSession
from sqlalchemy import select

from app.crud.conversation import create_conversation_service
from app.db import User, create_db_and_tables, get_async_session
from app.schemas import (
    ChatRequest,
    ConversationCreate,
    ConversationResponse,
    UserCreate,
    UserRead,
    UserUpdate,
)
from app.users import auth_backend, current_active_user, fastapi_users
from app.models import Conversation


# Load the environment variables.
load_dotenv()


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """
    This function is called when the FastAPI app starts and stops.
    It creates the database tables and yields the app.
    Args:
        app: The FastAPI app.
    Returns:
        None.
    """
    await create_db_and_tables()
    yield


# Create the FastAPI app.
app = FastAPI(lifespan=lifespan)
# Middleware. (We need this to allow the frontend to make requests to the backend).
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3001"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# This includes the authentication routes.
app.include_router(
    fastapi_users.get_auth_router(auth_backend), prefix="/auth/jwt", tags=["auth"]
)
# This includes the registration routes.
app.include_router(
    fastapi_users.get_register_router(UserRead, UserCreate),
    prefix="/auth",
    tags=["auth"],
)
# This includes the user routes.
app.include_router(
    fastapi_users.get_users_router(UserRead, UserUpdate),
    prefix="/users",
    tags=["users"],
)

# Create the Agno database.
agno_db = SqliteDb(db_file="agno.db")


@app.post("/api/v1/conversations")
async def create_conversation(
    conversation: ConversationCreate,
    user: User = Depends(current_active_user),
    session: AsyncSession = Depends(get_async_session),
) -> ConversationResponse:
    """
    Create a new conversation.
    Returns:
        ConversationResponse: The response containing the conversation details.
        The response contains the conversation id, title, user id, created at, and updated at.
    Architecture note: This creates a conversation in your database with a default title.
    The actual title will be generated by LLM based on first message.
    """

    new_conversation: Conversation = await create_conversation_service(
        user.id, session, conversation
    )
    # Return the conversation response.
    return ConversationResponse(
        title=new_conversation.title,
        id=new_conversation.id,
        user_id=new_conversation.user_id,
        created_at=new_conversation.created_at,
        updated_at=new_conversation.updated_at,
    )


@app.post("/api/chat")
def chat(
    request: ChatRequest, user: User = Depends(current_active_user)
) -> StreamingResponse:
    """
    This endpoint is used to chat with the Agno agent.
    Args:
        request: The request to the chat API.
        user: The current active user.
    Returns:
        A StreamingResponse object.
        The StreamingResponse object contains response from the Agno agent.
        The response is returned as a stream of events.
        The events are returned as a JSON object with a "type" key and a "content" key.
        The "type" key is either "delta" or "done".

    Architecture Overview:
    ------------------------
    Your Database: Stores conversation metadata (title, user_id, id)
    Agno Database: Stores actual messages and conversation history
    Link: Use your Conversation.id as Agno's session_id

    Flow:
    1. Frontend creates conversation via POST /api/v1/conversations
    2. Frontend sends chat with conversation_id
    3. Backend uses conversation_id as Agno's session_id
    4. Agno persists messages with that session_id
    5. Frontend can retrieve history via your API or Agno API
    """
    # TODO: Implement conversation_id handling in ChatRequest schema first
    # The schema should have: conversation_id: Optional[uuid.UUID]
    #
    # After adding conversation_id field to schema:
    # 1. Check if conversation_id is provided in request
    # 2. If yes: Verify user owns this conversation (get from your DB)
    # 3. Use conversation_id as Agno's session_id: session_id=str(conversation_id)
    # 4. If no conversation_id: Let Agno auto-generate new session_id
    # 5. Optionally: Create new conversation in your DB if needed
    #
    # Example code structure:
    # if request.conversation_id:
    #     db_conversation = await get_conversation(session, request.conversation_id, user.id)
    #     if not db_conversation or db_conversation.user_id != user.id:
    #         raise HTTPException(status_code=404, detail="Conversation not found")
    #     agno_session_id = str(request.conversation_id)
    # else:
    #     # New conversation - create it first
    #     db_conversation = await create_conversation_service(user.id, session, ConversationCreate())
    #     agno_session_id = str(db_conversation.id)  # Use your ID as Agno session

    # Create to Agno agent.
    agno_agent = Agent(
        name="Agno Agent",
        user_id=str(user.id),
        session_id=(str(request.conversation_id) if request.conversation_id else None),
        # When updating this, apparently the server needs to be restarted (?)
        model=Gemini(id="gemini-3-flash-preview"),
        # Add a database to the Agent
        db=agno_db,
        # Add to Agno MCP server to the Agent
        tools=[MCPTools(transport="streamable-http", url="https://docs.agno.com/mcp")],
        # Add to previous session history to the context
        add_history_to_context=True,
        num_history_runs=3,
        markdown=True,
    )

    # This is actually our final conversation id. (Gets created if we didn't pass one in.)
    # TODO: We need to return this to the frontend in some way, so it can keep track of it.
    # agno_agent.session_id;

    def event_stream():
        """
        Stream!
        """
        # Iterate Agno's streaming events
        for ev in agno_agent.run(request.question, stream=True):
            chunk = getattr(ev, "content", None)
            if chunk:
                # Send a "delta" payload to the client
                payload = {"type": "delta", "content": chunk}
                yield f"data: {json.dumps(payload)}\n\n"

        # Signal completion
        yield "data: [DONE]\n\n"

    return StreamingResponse(
        event_stream(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",
        },
    )

    # TODO: Add endpoint to get conversation by ID
    # @app.get("/api/v1/conversations/{conversation_id}")
    # async def get_conversation_endpoint(
    #     conversation_id: uuid.UUID,
    #     user: User = Depends(current_active_user),
    #     session: AsyncSession = Depends(get_async_session),
    # ) -> ConversationResponse:
    #     """
    #     Get a single conversation by ID.
    #
    #     Security: Verify user owns this conversation.
    #     """
    #     from app.crud.conversation import get_conversation
    #     db_conversation = await get_conversation(session, conversation_id, user.id)
    #     if not db_conversation:
    #         raise HTTPException(status_code=404, detail="Conversation not found")
    #
    #     # TODO: Optionally fetch messages from Agno's database
    #     # from app.crud.message import get_agno_messages
    #     # messages = await get_agno_messages(agno_db, str(conversation_id))
    #     # return ConversationResponse(
    #     #     id=db_conversation.id,
    #     #     user_id=db_conversation.user_id,
    #     #     title=db_conversation.title,
    #     #     created_at=db_conversation.created_at,
    #     #     updated_at=db_conversation.updated_at,
    #     #     messages=messages  # ← Add if you fetch from Agno
    #     )
    #     return ConversationResponse(
    #         id=db_conversation.id,
    #         user_id=db_conversation.user_id,
    #         title=db_conversation.title,
    #         created_at=db_conversation.created_at,
    #         updated_at=db_conversation.updated_at
    #     )

    # TODO: Add endpoint to list all conversations for user
    # @app.get("/api/v1/conversations")
    # async def list_conversations_endpoint(
    #     user: User = Depends(current_active_user),
    #     session: AsyncSession = Depends(get_async_session),
    #     skip: int = 0,
    #     limit: int = 100
    # ) -> list[ConversationResponse]:
    #     """
    #     List all conversations for the authenticated user.
    #
    #     Returns conversations ordered by updated_at DESC (most recent first).
    #     """
    #     from app.crud.conversation import get_conversations_for_user
    #     conversations = await get_conversations_for_user(session, user.id, skip, limit)
    #     return [
    #         ConversationResponse(
    #             id=conv.id,
    #             user_id=conv.user_id,
    #             title=conv.title,
    #             created_at=conv.created_at,
    #             updated_at=conv.updated_at
    #         )
    #         for conv in conversations
    #     ]

    # TODO: Add endpoint to update conversation title
    # @app.put("/api/v1/conversations/{conversation_id}")
    # async def update_conversation_endpoint(
    #     conversation_id: uuid.UUID,
    #     update_data: ConversationUpdate,
    #     user: User = Depends(current_active_user),
    #     session: AsyncSession = Depends(get_async_session),
    # ) -> ConversationResponse:
    #     """
    #     Update conversation metadata (title, etc.).
    #
    #     Use case: After LLM generates title from first message.
    #     """
    #     from app.crud.conversation import update_conversation
    #     updated_conv = await update_conversation(
    #         session,
    #         conversation_id,
    #         user.id,
    #         update_data
    #     )
    #     if not updated_conv:
    #         raise HTTPException(status_code=404, detail="Conversation not found")
    #
    #     return ConversationResponse(
    #         id=updated_conv.id,
    #         user_id=updated_conv.user_id,
    #         title=updated_conv.title,
    #         created_at=updated_conv.created_at,
    #         updated_at=updated_conv.updated_at
    #     )

    # TODO: Add endpoint to delete conversation
    # @app.delete("/api/v1/conversations/{conversation_id}")
    # async def delete_conversation_endpoint(
    #     conversation_id: uuid.UUID,
    #     user: User = Depends(current_active_user),
    #     session: AsyncSession = Depends(get_async_session),
    # ):
    #     """
    #     Delete a conversation and optionally its Agno session.
    #
    #     Use case: User deletes conversation from UI.
    #     """
    #     from app.crud.conversation import delete_conversation
    #     success = await delete_conversation(session, conversation_id, user.id)
    #     if not success:
    #         raise HTTPException(status_code=404, detail="Conversation not found")
    #
    #     # TODO: Optionally clear Agno session to clean up its database
    #     # from agno.agent import Agent
    #     # agent = Agent(db=agno_db)
    #     # agent.get_session(session_id=str(conversation_id)).clear()
    #
    #     return {"message": "Conversation deleted"}

    # TODO: Add endpoint to get messages for a conversation
    # @app.get("/api/v1/conversations/{conversation_id}/messages")
    # async def get_conversation_messages_endpoint(
    #     conversation_id: uuid.UUID,
    #     user: User = Depends(current_active_user),
    #     session: AsyncSession = Depends(get_async_session),
    # ):
    #     """
    #     Get all messages for a conversation.
    #
    #     Messages can come from:
    #     1. Your database (mirror of Agno)
    #     2. Agno's database (actual source)
    #     3. Both (merge for completeness)
    #     """
    #     from app.crud.message import get_messages_by_conversation, get_agno_messages
    #
    #     # Option 1: Get from your DB (faster for basic list)
    #     your_messages = await get_messages_by_conversation(session, conversation_id)
    #
    #     # Option 2: Get from Agno's DB (actual source)
    #     agno_messages = await get_agno_messages(agno_db, str(conversation_id))
    #
    #     # Merge or return one source
    #     return {
    #         "conversation_id": conversation_id,
    #         "messages": agno_messages,  # ← Prefer Agno's (actual source)
    #         "your_db_messages": your_messages  # ← Optional: backup/debug
    #     }

    def event_stream():
        """
        Stream!
        """
        # Iterate Agno's streaming events
        for ev in agno_agent.run(request.question, stream=True):
            chunk = getattr(ev, "content", None)
            if chunk:
                # Send a "delta" payload to the client
                payload = {"type": "delta", "content": chunk}
                yield f"data: {json.dumps(payload)}\n\n"

        # Signal completion
        yield "data: [DONE]\n\n"

    return StreamingResponse(
        event_stream(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "X-Accel-Buffering": "no",
        },
    )
